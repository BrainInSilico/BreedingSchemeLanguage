p <- p + guides(linetype=guide_legend("Scheme"))
print(p)
}
#' Save the results
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param summarize if T a result averaged over all the replications is saved, if F each replication's result is saved
#'@param directory the directory to which the output will be saved (Enclose the name in double quotation!) (default: the current directory)
#'@param saveDataFileName the file name to save the simulated data with double-quotation, like "result1_1". (default: "BSLoutput")
#'
#'@return The simulation results (The output data was saved as BSLoutput.RData. After you load the data in R, you can find the data named as BSLoutput.)
#'
#'@export
outputResults <- function(sEnv=simEnv, summarize=T, directory=".", saveDataFileName="BSLoutput"){
if(summarize){
getMean <- function(data){
tapply(data$genoRec$gValue, data$genoRec$basePopID, mean)
}
getVar <- function(data){
tapply(data$genoRec$gValue, data$genoRec$basePopID, var)
}
muSim <- sapply(sEnv$sims, getMean)
varSim <- sapply(sEnv$sims, getVar)
BSLoutput <- cbind(muSim, varSim)
# rownames(BSLoutput) <- popID
colnames(BSLoutput) <- c(paste("mu", 1:sEnv$nSim, sep=""), paste("var", 1:sEnv$nSim, sep=""))
}else{
BSLoutput <- sEnv$sims
}
saveRDS(BSLoutput, file=paste(directory, "/", saveDataFileName, ".rds", sep=""))
}
#'Evaluate the phenotypic value
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param errorVar error variance
#'@param popID population ID to be evaluated (default: the latest population)
#'@param locations integer vector of the locations where phenotyping occurs (e.g., c(1, 3) to phenotype at locations 1 and 3. Default: 1, phenotype at the first location)
#'@param years integer vector of the years when phenotypin occurs (e.g., 1:2 to phenotype during the first two years of the breeding scheme. Default: 1, phenotype the first year)
#'
#'@return phenotypic values and the all information created before (list)
#'@export
# Locations and years get added when you phenotype in them for the first time
phenotype <- function(sEnv=simEnv, errorVar=1, popID=NULL, locations=1, years=1){
parent.env(sEnv) <- environment()
phenotype.func <- function(data, errorVar, popID, locations, years){
# Who to phenotype
if(is.null(popID)){
popID <- max(data$genoRec$popID)
}
tf <- data$genoRec$popID %in% popID
pValue <- calcPhenotypicValue(gv=data$gValue[tf,], errorVar=errorVar)
nPhen <- nrow(pValue)
# Year and location effects to add in
nInd <- max(data$genoRec$GID)
nAdd <- max(years) - ncol(data$yearEffects)
if (nAdd > 0){
vp <- data$varParms$gByYearVar * data$varParms$fracGxEAdd
toAdd <- rmvnorm(nAdd, mu=rep(0, nInd), Sigma=data$qtlRelMat) * sqrt(vp)
data$yearEffects <- cbind(data$yearEffects, toAdd)
vp <- data$varParms$gByYearVar * (1 - data$varParms$fracGxEAdd)
toAdd <- matrix(rnorm(nInd * nAdd, sd=sqrt(vp)), nInd)
data$yearEffectsI <- cbind(data$yearEffectsI, toAdd)
}
if (data$randLoc){
nAdd <- max(locations) - ncol(data$locEffects)
if (nAdd > 0){
vp <- data$varParms$gByLocVar * data$varParms$fracGxEAdd
toAdd <- rmvnorm(nAdd, mu=rep(0, nInd), Sigma=data$qtlRelMat) * sqrt(vp)
data$locEffects <- cbind(data$locEffects, toAdd)
vp <- data$varParms$gByLocVar * (1 - data$varParms$fracGxEAdd)
toAdd <- matrix(rnorm(nInd * nAdd, sd=sqrt(vp)), nInd)
data$locEffectsI <- cbind(data$locEffectsI, toAdd)
}
}
nLoc <- length(locations)
nYr <- length(years)
if (data$randLoc){
pValue <- rep(pValue, nLoc * nYr)
pValue <- pValue + data$locEffects[tf, locations] + data$locEffectsI[tf, locations]
} else{
pValue <- rep(pValue[tf, locations], nYr)
}
ye <- NULL; for (i in years) ye <- c(ye, rep(data$yearEffects[,i], nLoc))
pValue <- pValue + ye
ye <- NULL; for (i in years) ye <- c(ye, rep(data$yearEffectsI[,i], nLoc))
pValue <- pValue + ye
locFact <- as.factor(rep(locations, each=nPhen))
yrFact <- as.factor(rep(years, each=nPhen*nLoc))
toAdd <- data.frame(phenoGID=as.factor(data$genoRec$GID[tf]), loc=locFact, year=yrFact, error=errorVar, pValue=pValue)
data$phenoRec <- rbind(data$phenoRec, toAdd)
data$selCriterion <- list(popID=popID, criterion="pheno")
# Take care of costs
if (exists("totalCost", data){
perPlotCost <- abs(data$costs$phenoCost$error - errorVar)
perPlotCost <- which(perPlotCost == min(perPlotCost))
perPlotCost <- data$costs$phenoCost$cost[perPlotCost]
data$totalCost <- data$totalCost + nPhen * perPlotCost * nLoc * nYr
}
return(data)
}
with(sEnv, {
if(nCore > 1){
sfInit(parallel=T, cpus=nCore)
sims <- sfLapply(sims, phenotype.func, errorVar=errorVar, popID=popID)
sfStop()
}else{
sims <- lapply(sims, phenotype.func, errorVar=errorVar, popID=popID)
}
})
}
#'Evaluate the phenotypic value
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param errorVar error variance
#'@param popID population ID to be evaluated (default: the latest population)
#'@param locations integer vector of the locations where phenotyping occurs (e.g., c(1, 3) to phenotype at locations 1 and 3. Default: 1, phenotype at the first location)
#'@param years integer vector of the years when phenotypin occurs (e.g., 1:2 to phenotype during the first two years of the breeding scheme. Default: 1, phenotype the first year)
#'
#'@return phenotypic values and the all information created before (list)
#'@export
# Locations and years get added when you phenotype in them for the first time
phenotype <- function(sEnv=simEnv, errorVar=1, popID=NULL, locations=1, years=1){
parent.env(sEnv) <- environment()
phenotype.func <- function(data, errorVar, popID, locations, years){
# Who to phenotype
if(is.null(popID)){
popID <- max(data$genoRec$popID)
}
tf <- data$genoRec$popID %in% popID
pValue <- calcPhenotypicValue(gv=data$gValue[tf,], errorVar=errorVar)
nPhen <- nrow(pValue)
# Year and location effects to add in
nInd <- max(data$genoRec$GID)
nAdd <- max(years) - ncol(data$yearEffects)
if (nAdd > 0){
vp <- data$varParms$gByYearVar * data$varParms$fracGxEAdd
toAdd <- rmvnorm(nAdd, mu=rep(0, nInd), Sigma=data$qtlRelMat) * sqrt(vp)
data$yearEffects <- cbind(data$yearEffects, toAdd)
vp <- data$varParms$gByYearVar * (1 - data$varParms$fracGxEAdd)
toAdd <- matrix(rnorm(nInd * nAdd, sd=sqrt(vp)), nInd)
data$yearEffectsI <- cbind(data$yearEffectsI, toAdd)
}
if (data$randLoc){
nAdd <- max(locations) - ncol(data$locEffects)
if (nAdd > 0){
vp <- data$varParms$gByLocVar * data$varParms$fracGxEAdd
toAdd <- rmvnorm(nAdd, mu=rep(0, nInd), Sigma=data$qtlRelMat) * sqrt(vp)
data$locEffects <- cbind(data$locEffects, toAdd)
vp <- data$varParms$gByLocVar * (1 - data$varParms$fracGxEAdd)
toAdd <- matrix(rnorm(nInd * nAdd, sd=sqrt(vp)), nInd)
data$locEffectsI <- cbind(data$locEffectsI, toAdd)
}
}
nLoc <- length(locations)
nYr <- length(years)
if (data$randLoc){
pValue <- rep(pValue, nLoc * nYr)
pValue <- pValue + data$locEffects[tf, locations] + data$locEffectsI[tf, locations]
} else{
pValue <- rep(pValue[tf, locations], nYr)
}
ye <- NULL; for (i in years) ye <- c(ye, rep(data$yearEffects[,i], nLoc))
pValue <- pValue + ye
ye <- NULL; for (i in years) ye <- c(ye, rep(data$yearEffectsI[,i], nLoc))
pValue <- pValue + ye
locFact <- as.factor(rep(locations, each=nPhen))
yrFact <- as.factor(rep(years, each=nPhen*nLoc))
toAdd <- data.frame(phenoGID=as.factor(data$genoRec$GID[tf]), loc=locFact, year=yrFact, error=errorVar, pValue=pValue)
data$phenoRec <- rbind(data$phenoRec, toAdd)
data$selCriterion <- list(popID=popID, criterion="pheno")
# Take care of costs
if (exists("totalCost", data)){
perPlotCost <- abs(data$costs$phenoCost$error - errorVar)
perPlotCost <- which(perPlotCost == min(perPlotCost))
perPlotCost <- data$costs$phenoCost$cost[perPlotCost]
data$totalCost <- data$totalCost + nPhen * perPlotCost * nLoc * nYr
}
return(data)
}
with(sEnv, {
if(nCore > 1){
sfInit(parallel=T, cpus=nCore)
sims <- sfLapply(sims, phenotype.func, errorVar=errorVar, popID=popID)
sfStop()
}else{
sims <- lapply(sims, phenotype.func, errorVar=errorVar, popID=popID)
}
})
}
#'Create a founder population
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param nInd population size
#'
#'@return initial population informationand the all information created before (list)
#'
#'@export
initializePopulation <- function(sEnv=simEnv, nInd=100){
parent.env(sEnv) <- environment()
initializePopulation.func <- function(data, nInd){
seed <- round(runif(1, 0, 1e9))
md <- data$mapData
geno <- data$founderHaps * 2 - 1
data$founderHaps <- NULL
geno <- geno[sample(nrow(geno), nInd*2, replace=T),]
geno <- randomMate(popSize=nInd, geno=geno, pos=md$map$Pos)
pedigree <- -geno$pedigree # For founders, parents will be negative
geno <- geno$progenies
M <- (geno[1:nInd*2 - 1, md$effectivePos] + geno[1:nInd*2, md$effectivePos]) / 2
M <- scale(M, center=T, scale=F)
mrkCenter <- attr(M, "scaled:center")
mrkConst <- mrkCenter / 2 + 0.5; mrkConst <- 2 * crossprod(mrkConst, 1 - mrkConst)
qtlRelMat <- tcrossprod(scale(M, center=T, scale=F)) / mrkConst
# Genetic effects. This works even if locCov is scalar
gValue <- calcGenotypicValue(geno=geno, mapData=md)
coef <- solve(chol(var(gValue))) %*% chol(data$varParms$locCov)
md$effects <- md$effects %*% coef
gValue <- gValue %*% coef
# Year and location effects: create matrices with zero columns until phenotyped
locEffects <- matrix(0, nrow=nInd, ncol=0)
locEffectsI <- matrix(0, nrow=nInd, ncol=0)
yearEffects <- matrix(0, nrow=nInd, ncol=0)
yearEffectsI <- matrix(0, nrow=nInd, ncol=0)
GID <- 1:nInd
popID <- rep(0, nInd)
hasGeno <- rep(FALSE, nInd)
genoRec <- data.frame(GID=GID, pedigree=pedigree, popID=popID, basePopID=popID, hasGeno=hasGeno)
data$mapData <- md
data <- c(data, geno=geno, genoRec=genoRec, gValue=gValue, locEffects=locEffects, locEffectsI=locEffectsI, yearEffects=yearEffects, yearEffectsI=yearEffectsI, mrkCenter=mrkCenter, mrkConst=mrkConst, qtlRelMat=qtlRelMat)
return(data)
}
with(sEnv, {
if(nCore > 1){
sfInit(parallel=T, cpus=nCore)
sims <- sfLapply(sims, initializePopulation.func, nInd=nInd)
sfStop()
}else{
sims <- lapply(sims, initializePopulation.func, nInd=nInd)
}
})
}
#'Genotype markers
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param popID population ID to be genotyped (default: all populations)
#'@return marker genotype and the all information created before (list)
#'
#'@export
genotype <- function(sEnv=simEnv, popID=NULL){
parent.env(sEnv) <- environment()
genotype.func <- function(data){
nHasGeno <- sum(data$genoRec$hasGeno)
if (is.null(popID)){
data$genoRec$hasGeno <- TRUE
} else{
tf <- data$genoRec$popID %in% popID
data$genoRec$hasGeno <- data$genoRec$hasGeno | tf
}
if (exists("totalCost", data)) data$totalCost <- data$totalCost + (sum(data$genoRec$hasGeno) - nHasGeno) * data$costs$genoCost
return(data)
}
with(sEnv, {
# This is too fast to want to parallelize
sims <- lapply(sims, genotype.func)
})
}
#'Genotype markers
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param popID population ID to be genotyped (default: all populations)
#'@return marker genotype and the all information created before (list)
#'
#'@export
genotype <- function(sEnv=simEnv, popID=NULL){
parent.env(sEnv) <- environment()
genotype.func <- function(data){
nHasGeno <- sum(data$genoRec$hasGeno)
if (is.null(popID)){
data$genoRec$hasGeno <- TRUE
} else{
tf <- data$genoRec$popID %in% popID
data$genoRec$hasGeno <- data$genoRec$hasGeno | tf
}
if (exists("totalCost", data)) data$totalCost <- data$totalCost + (sum(data$genoRec$hasGeno) - nHasGeno) * data$costs$genoCost
return(data)
}
with(sEnv, {
# This is too fast to want to parallelize
sims <- lapply(sims, genotype.func)
})
}
#'Doubled haploids
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param nProgeny the number of progeny
#'@param popID population ID to be devided by meiosis and doubled (default: the latest population)
#'
#'@return sequence information of progenies and the all information created before (list)
#'
#'@export
doubledHaploid <- function(sEnv=simEnv, nProgeny=100, popID=NULL){
parent.env(sEnv) <- environment()
doubledHaploid.func <- function(data, nProgeny, popID){
locPos <- data$mapData$map$Pos
if(is.null(popID)){
popID <- max(data$genoRec$popID)
}
tf <- data$genoRec$popID %in% popID
GIDpar <- data$genoRec$GID[tf]
nPar <- length(GIDpar)
geno <- data$geno[rep(GIDpar*2, each=2) + rep(-1:0, nPar),]
geno <- makeDHs(popSize=nProgeny, geno=geno, pos=locPos)
pedigree <- cbind(matrix(GIDpar[geno$pedigree], nProgeny), -1)
geno <- geno$progenies
data <- addProgenyData(data, geno, pedigree)
if (exists("totalCost", data)) data$totalCost <- data$totalCost + nProgeny * data$costs$doubHapCost
return(data)
}
with(sEnv, {
if(nCore > 1){
sfInit(parallel=T, cpus=nCore)
sims <- sfLapply(sims, doubledHaploid.func, nProgeny=nProgeny, popID=popID)
sfStop()
} else{
sims <- lapply(sims, doubledHaploid.func, nProgeny=nProgeny, popID=popID)
}
})
}
#' Define the relationships among locations
#' NOTE: if this function is not called, genotype by location and genotype by year effects
#' are not used in the simulation
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param gVariance genetic variance in the initial population
#'@param gByLocVar scalar: the genotype by location variance (default: 1 BUT if locCorrelations given, this parameter is not used)
#'@param gByYearVar scalar: the genotype by year variance (default: 1)
#'@param fracGxEAdd scalar: for GxL and GxY what fraction of the effect is additive versus non-additive
#'@param nLoc scalar: number of locations default: if locCorrelations given, nrow(locCorrelations), else 2
#'@param locCorrelations matrix: genetic correlation in performance between locations default: NULL will cause locCorrelations to be gVariance / (gVariance + gByLocVar). If given, the genetic variance-covariance across locations is gVariance * locCorrelations
#'
#'@return Species information and input values for the simulation (list)
#'
#'@export
defineVariances <- function(sEnv=simEnv, gVariance=1, locCorrelations=NULL, nLoc=2, gByLocVar=1, gByYearVar=1, fracGxEAdd=0.8){
parent.env(sEnv) <- environment()
loc.func <- function(data){
randLoc <- is.null(locCorrelations)
if (randLoc){ # compound symmetric GxE here, with only g defined explicitly
locCov <- gVariance
} else{
nLoc <- nrow(locCorrelations)
locCov <- gVariance * locCorrelations
}
nQTL <- max(data$mapData$effectID)
data$mapData$effects <- matrix(rnorm(nQTL * nrow(locCov)), nQTL) %*% chol(locCov)
data$varParms <- list(gVariance=gVariance, gByLocVar=gByLocVar, gByYearVar=gByYearVar, fracGxEAdd=fracGxEAdd, randLoc=randLoc, locCov=locCov)
return(data)
}
with(sEnv, {
if(nCore > 1){
sfInit(parallel=T, cpus=nCore)
sims <- sfLapply(sims, loc.func)
sfStop()
}else{
sims <- lapply(sims, loc.func)
}
})
}
#' Define the costs that go into breeding
#' Default for some costs is zero because they probably belong to fixed costs
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param phenoCost two-column lookup table with error variance in first column and cost in second column (default: 1, 1)
#'@param genoCost scalar: cost to genotype one individual default (0.25)
#'@param crossCost scalar: cost of creating a new individual from a cross (1)
#'@param selfCost scalar: the cost of creating a selfed seed (1)
#'@param doubHapCost scalar: the cost of creating a doubled haploid seed (5)
#'@param predCost scalar: the cost of running the analysis to make predictions (0)
#'@param selectCost scalar: the cost of running the analysis to do selection (0)
#'@param locCost scalar: the cost of maintaining a location for a year (0)
#'@param yearCost scalar: the cost of program upkeep for a year (0)
#'
#'@return Species information and input values for the simulation (list)
#'
#'@export
defineCosts <- function(sEnv=simEnv, phenoCost=data.frame(1,1), genoCost=0.25, crossCost=1, selfCost=1, doubHapCost=5, predCost=0, selectCost=0, locCost=0, yearCost=0){
parent.env(sEnv) <- environment()
cost.func <- function(data){
colnames(phenoCost) <- c("error", "cost")
data$costs <- list(phenoCost=phenoCost, genoCost=genoCost, crossCost=crossCost, selfCost=selfCost, doubHapCost=doubHapCost, predCost=predCost, selectCost=selectCost, locCost=locCost, yearCost=yearCost)
data$totalCost <- 0
return(data)
}
with(sEnv, {
# This is too fast to want to parallelize
sims <- lapply(sims, cost.func)
})
}
#' Cross with random mating, or equal contributions,
#'or randomly between two populations
#'
#'@param sEnv the environment that BSL functions operate in. Default is "simEnv" so use that to avoid specifying when calling functions
#'@param nProgeny the number of progenies
#'@param equalContribution if T all individuals used the same number of times as parents, if F individuals chosen at random to be parents
#'@param popID population ID to be crossed (default: the latest population)
#'@param popID2 population ID to be crossed with popID to make hybrids
#'
#'@return sequence information of progenies and the all information created before (list)
#'
#'@export
cross <- function(sEnv=simEnv, nProgeny=100, equalContribution=F, popID=NULL, popID2=NULL){
parent.env(sEnv) <- environment()
cross.func <- function(data, nProgeny, equalContribution, popID, popID2){
locPos <- data$mapData$map$Pos
if(is.null(popID)){
popID <- max(data$genoRec$popID)
}
tf <- data$genoRec$popID %in% popID
GID.1 <- data$genoRec$GID[tf]
nPar1 <- length(GID.1)
geno <- data$geno[rep(GID.1*2, each=2) + rep(-1:0, nPar1), ]
if (is.null(popID2)){
if(equalContribution){
geno <- randomMateAll(popSize=nProgeny, geno=geno, pos=locPos)
}else{
geno <- randomMate(popSize=nProgeny, geno=geno, pos=locPos)
}
pedigree <- cbind(matrix(GID.1[geno$pedigree], nrow=nProgeny), 0)
geno <- geno$progenies
} else{ # Make pedigrees to mate two populations with each other
tf <- data$genoRec$popID %in% popID2
GID.2 <- data$genoRec$GID[tf]
nPar2 <- length(GID.2)
geno <- rbind(geno, data$geno[rep(GID.2*2, each=2) + rep(-1:0, nPar2), ])
par1 <- sample(c(rep(1:nPar1, nProgeny %/% nPar1), sample(nPar1, nProgeny %% nPar1)))
par2 <- nPar1 + sample(c(rep(1:nPar2, nProgeny %/% nPar2), sample(nPar2, nProgeny %% nPar2)))
parents <- cbind(sample(par1), sample(par2))
geno <- makeProgenies(parents, geno, locPos)
pedigree <- cbind(GID.1[parents[,1]], GID.2[parents[,2]-nPar1], 0)
}
}
data <- addProgenyData(data, geno, pedigree)
if (exists("totalCost", data)) data$totalCost <- data$totalCost + nProgeny * data$costs$crossCost
return(data)
with(sEnv, {
if(nCore > 1){
sfInit(parallel=T, cpus=nCore)
sims <- sfLapply(sims, cross.func, nProgeny=nProgeny, equalContribution=equalContribution, popID=popID, popID2=popID2)
sfStop()
} else{
sims <- lapply(sims, cross.func, nProgeny=nProgeny, equalContribution=equalContribution, popID=popID, popID2=popID2)
}
})
}
#' Add progeny information to data after cross, doubledHaploid, or selfFertilize
#'
#'@param data the list that has all the objects for one simulation
#'@param geno the genotypes of the progeny
#'@param pedigree the three-column pedigree of the progeny (last col: DH, outbred, self)
#'
#'@return data with progeny information added
#'
addProgenyData <- function(data, geno, pedigree){
# Add on to genetic values
gValue <- calcGenotypicValue(geno=geno, mapData=data$mapData)
data$gValue <- rbind(data$gValue, gValue)
# Add on to the QTL relationship matrix
nPrev <- max(data$genoRec$GID)
nProgeny <- nrow(geno) / 2
Mp <- (data$geno[1:nPrev*2 - 1, data$mapData$effectivePos] + data$geno[1:nPrev*2, data$mapData$effectivePos]) / 2
Mp <- Mp - rep(data$mrkCenter, each=nPrev)
Mn <- (geno[1:nProgeny*2 - 1, data$mapData$effectivePos] + geno[1:nProgeny*2, data$mapData$effectivePos]) / 2
Mn <- Mn - rep(data$mrkCenter, each=nProgeny)
Mp <- crossprod(Mn, Mp) / data$mrkConst
Mn <- tcrossprod(Mn) / data$mrkConst
# Use that to add on to locEffects and yearEffects
MppInv <- Mp %*% solve(data$qtlRelMat)
varEff <- Mn - MppInv %*% t(Mp)
nAdd <- ncol(data$yearEffects)
if (nAdd > 0){
vp <- data$varParms$gByYearVar * data$varParms$fracGxEAdd
toAdd <- rmvnorm(nAdd, MppInv %*% data$yearEffects, varEff) * sqrt(vp)
data$yearEffects <- rbind(data$yearEffects, t(toAdd))
vp <- data$varParms$gByYearVar * (1 - data$varParms$fracGxEAdd)
toAdd <- matrix(rnorm(nProgeny * nAdd, sd=sqrt(vp)), nProgeny)
data$yearEffectsI <- rbind(data$yearEffectsI, toAdd)
}
if (data$randLoc){
nAdd <- ncol(data$locEffects)
if (nAdd > 0){
vp <- data$varParms$gByLocVar * data$varParms$fracGxEAdd
toAdd <- rmvnorm(nAdd, MppInv %*% data$locEffects, varEff) * sqrt(vp)
data$locEffects <- rbind(data$locEffects, t(toAdd))
vp <- data$varParms$gByLocVar * (1 - data$varParms$fracGxEAdd)
toAdd <- matrix(rnorm(nProgeny * nAdd, sd=sqrt(vp)), nProgeny)
data$locEffectsI <- rbind(data$locEffectsI, toAdd)
}
}
data$qtlRelMat <- cbind(rbind(data$qtlRelMat, Mp), rbind(t(Mp), Mn))
# Add on to the genotypic records
GID <- max(data$genoRec$GID) + 1:nProgeny
popID <- rep(max(data$genoRec$popID) + 1, nProgeny)
hasGeno <- rep(FALSE, nProgeny)
addRec <- data.frame(GID=GID, pedigree=pedigree, popID=popID, basePopID=popID, hasGeno=hasGeno)
colnames(addRec) <- colnames(genoRec)
data$genoRec <- rbind(data$genoRec, addRec)
# Add on to the genotypes
data$geno <- rbind(data$geno, geno)
return(data)
}
remove.packages("BreedingSchemeLanguage")
quit(save="no")
